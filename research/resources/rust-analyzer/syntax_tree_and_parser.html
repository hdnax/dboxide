<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Syntax Tree &amp; Parser - dboxide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../../../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../../../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../../../css/general-2459343d.css">
        <link rel="stylesheet" href="../../../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../../../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../../../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../../../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../../../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../../searchindex-96745181.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc-1770bef2.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">dboxide</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/hdnax/dboxide/tree/main/doc" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/hdnax/dboxide/tree/main/doc" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="syntax-tree--parser"><a class="header" href="#syntax-tree--parser">Syntax Tree &amp; Parser</a></h1>
<p>Official site: <a href="https://rust-analyzer.github.io/book/contributing/syntax.html">Link</a>.</p>
<p>Commit link: <a href="https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6">2020-01-09</a></p>
<h2 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h2>
<ul>
<li>The system has three isolated components:
<ul>
<li><a href="https://github.com/rust-analyzer/rowan/tree/v0.15.10"><code>rowan</code></a>: A generic, language-agnostic library for immutable syntax trees using the Red-Green tree model.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax"><code>syntax</code> (crate)</a>: Wrap <code>rowan</code> with a <code>rust-analyzer</code>-specific API. It’s the only crate that knows about <code>rowan</code>.</li>
<li><a href="https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_parser"><code>parser</code> (crate)</a>: Output events from parsing without knowing anything about the tree structure.</li>
</ul>
</li>
</ul>
<h2 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h2>
<ul>
<li>Lossless: Everything is preserved—whitespace, comments, even invalid tokens.</li>
<li>Semantic-less: Pure structure with no type checking or name resolution.</li>
<li>Context-free: Trees are simple values that don’t depend on external context.</li>
<li>Resilient: Always produce a tree, even from broken code (nodes may be partial).</li>
<li>Performance: Optimized for memory and CPU using <code>unsafe</code> where needed.</li>
<li>Decoupled: Parser and tree evolve independently.</li>
<li>Intuitive traversal: Easy navigation between parent, children, and siblings.</li>
</ul>
<h2 id="the-three-layer-syntax-tree"><a class="header" href="#the-three-layer-syntax-tree">The Three-Layer Syntax Tree</a></h2>
<p>The core idea is a “Red-Green Tree” (borrowed from Roslyn), where three layers balance memory usage against API convenience.</p>
<ul>
<li><em>Semi-transient</em>: Trees don’t live in memory permanently—they get lowered to a compact form but can be rebuilt when needed.</li>
</ul>
<h3 id="layer-1-greennode-the-storage"><a class="header" href="#layer-1-greennode-the-storage">Layer 1: GreenNode (The Storage)</a></h3>
<ul>
<li>
<p>GreenNode is where the actual data lives—it’s purely functional, immutable, and persistent with arbitrary arity.</p>
</li>
<li>
<p>Conceptual (unoptimized) example from <code>rust-analyzer</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Runtime tag for a Node/Token
// Nodes and tokens both use the same tag kind?
#[derive(PartialEq, Eq, Clone, Copy)]
struct SyntaxKind(u16);

#[derive(PartialEq, Eq, Clone)]
struct Node {
    kind: SyntaxKind,
    // Only the byte-length is stored, offset is not stored
    text_len: usize,
    // A generic node with a sequence of children nodes and tokens
    // `Arc` is used, so it allows for multithreading
    children: Vec&lt;Arc&lt;Either&lt;Node, Token&gt;&gt;&gt;,
}

#[derive(PartialEq, Eq, Clone)]
struct Token {
    kind: SyntaxKind,
    text: String,
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p>A <code>Token</code> is a leaf node, while <code>Node</code> represents interior nodes.</p>
</li>
<li>
<p>Some things to note:</p>
<ul>
<li>There’s just one generic node structure—nodes are untyped with a runtime tag.</li>
<li>The original text comes from combining all the children’s text.</li>
<li>Finding a specific child means scanning through siblings linearly.</li>
<li>Modifying the tree gets more expensive with height (due to path copying).</li>
<li>Invalid input gets wrapped in an <code>ERROR</code> node.</li>
<li>Errors live separately, not embedded in the tree itself.</li>
</ul>
</li>
</ul>
<p>The following optimizations are mostly attributed to <a href="https://github.com/cad97">CAD97</a>.</p>
<h4 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h4>
<pre><code class="language-text">[ RefCount | Kind | TextLen | N_Children | Child_1 | Child_2 | ... | Child_N ]
&lt;------------------------- Single Heap Allocation -------------------------&gt;
</code></pre>
<ul>
<li>Dynamically sized type (DST): Everything in one heap allocation instead of splitting the node and its children into separate allocations.</li>
<li>Tagged pointers: A single pointer where the last bit indicates whether it’s a <code>Node</code> or <code>Token</code> (cheaper than <code>Arc&lt;Either&lt;Node, Token&gt;&gt;</code>).</li>
<li>Interning: Tokens get reused—<code>1 + 1</code> only stores one <code>1</code> token that’s shared. Returns <code>Arc&lt;Node&gt;</code> so trees are self-contained.</li>
<li><code>TextSize</code>: Just a newtyped <code>u32</code> for tracking text length.</li>
<li><code>SmolStr</code>: Small strings like <code>fn</code> or <code>if</code> live on the stack inline, no heap allocation needed.
<ul>
<li>Note: The text suggests moving this data directly into the interned token allocation in the future.</li>
</ul>
</li>
</ul>
<h4 id="alternative-designs"><a class="header" href="#alternative-designs">Alternative Designs</a></h4>
<h5 id="dealing-with-trivia"><a class="header" href="#dealing-with-trivia">Dealing With Trivia</a></h5>
<ul>
<li>
<p>Explicit nodes (Rowan/IntelliJ): Whitespace becomes regular sibling nodes. Lossless and easy to edit, but noisy when traversing.</p>
</li>
<li>
<p>Attached trivia (Roslyn/Swift): Whitespace hides inside tokens as “leading/trailing” properties, so the tree only shows logical code.</p>
</li>
<li>
<p>Linked list (Dart): A hybrid approach with a clean semantic tree plus a separate doubly-linked list for all tokens.</p>
</li>
<li>
<p>There’s no standard approach to handling trivia. For reference, <code>@dbml/parse</code> uses the attached trivia approach.</p>
</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Strategy</th><th style="text-align: left">Pros</th><th style="text-align: left">Cons</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Explicit Nodes</strong><br>(Rowan, IntelliJ, <code>rust-analyzer</code>)</td><td style="text-align: left"><strong>Uniformity:</strong> Everything is a node; simple data model.<br><strong>Fidelity:</strong> Lossless representation of text.<br><strong>Refactoring:</strong> Moving a branch naturally moves its formatting.</td><td style="text-align: left"><strong>Noise:</strong> Tree traversal requires manual filtering of whitespace.<br><strong>Memory:</strong> Higher node count (every space is an object).</td></tr>
<tr><td style="text-align: left"><strong>Attached Trivia</strong><br>(Roslyn, Swift)</td><td style="text-align: left"><strong>Clarity:</strong> Tree contains <em>only</em> logical code.<br><strong>Iteration:</strong> Iterating children yields immediate semantic tokens.</td><td style="text-align: left"><strong>Complexity:</strong> “Re-stitching” text during refactoring is hard.<br><strong>Ownership:</strong> Ambiguous whether a comment belongs to the previous or next token.</td></tr>
<tr><td style="text-align: left"><strong>Linked List</strong><br>(Dart)</td><td style="text-align: left"><strong>Dual View:</strong> Optimized for both semantic analysis (Tree) and formatting (List).<br><strong>Scanning:</strong> Linear access to tokens is very fast.</td><td style="text-align: left"><strong>Syncing:</strong> High maintenance cost to keep the Tree and List in perfect sync.<br><strong>Overhead:</strong> Requires managing parallel data structures.</td></tr>
</tbody>
</table>
</div>
<h5 id="accessing-children"><a class="header" href="#accessing-children">Accessing Children</a></h5>
<ul>
<li>Linear can (IntelliJ/Rowan):
<ul>
<li>Children live in a dynamic list with trivia mixed in.</li>
<li>You have to scan through siblings (<strong>O(N)</strong>) to find what you want.</li>
<li>Very memory efficient—missing nodes cost nothing.</li>
</ul>
</li>
<li>Fixed slots (Roslyn/Swift):
<ul>
<li>Every possible child gets a fixed slot in the grammar.</li>
<li>Direct <strong>O(1)</strong> access by index.</li>
<li>Uses more memory since it allocates slots even for <code>None</code> values.</li>
<li>Trivia has to be removed to keep indices stable.</li>
</ul>
</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Feature</th><th style="text-align: left">Linear Scan (IntelliJ)</th><th style="text-align: left">Fixed Slots (Roslyn/Swift)</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Access Speed</strong></td><td style="text-align: left"><strong>O(N)</strong> (Must iterate/skip)</td><td style="text-align: left"><strong>O(1)</strong> (Direct Index)</td></tr>
<tr><td style="text-align: left"><strong>Memory Usage</strong></td><td style="text-align: left"><strong>Compact</strong> (Only stores present data)</td><td style="text-align: left"><strong>Sparse</strong> (Allocates slots for <code>None</code>)</td></tr>
<tr><td style="text-align: left"><strong>Missing Nodes</strong></td><td style="text-align: left">Implicitly absent</td><td style="text-align: left">Explicitly stored as <code>Option::None</code></td></tr>
<tr><td style="text-align: left"><strong>Trivia</strong></td><td style="text-align: left">Included as sibling nodes</td><td style="text-align: left">Removed or attached to tokens</td></tr>
</tbody>
</table>
</div>
<h5 id="mutable-trees"><a class="header" href="#mutable-trees">Mutable Trees</a></h5>
<ul>
<li>Mutable trees (IntelliJ): <strong>Imperative</strong> style.
<ul>
<li>You modify nodes directly in place (<code>node.delete()</code>).</li>
<li>Simple API but thread-safety gets complicated (need read/write locks).</li>
</ul>
</li>
<li>Immutable trees (<code>rust-analyzer</code>): <strong>Functional</strong> style.
<ul>
<li>You build up changes with a <code>Builder</code> then generate a fresh tree.</li>
<li>More verbose API, but concurrency becomes trivial (snapshots are naturally safe).</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// MUTABLE (IntelliJ Style)
// Direct, in-place modification. Simple but requires locking.
for bound in bounds {
    // The tree changes immediately
    bound.delete();
}

// IMMUTABLE (rust-analyzer Style)
// Indirect. Must collect edits and rebuild the tree structure.
let mut builder = tree.edit();
for bound in bounds {
    // Schedule deletion on the 'builder', not the node itself
    builder.delete(bound);
}
// Apply generates a completely new root node
let new_tree_root = builder.apply();

<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Feature</th><th style="text-align: left">Mutable Trees (IntelliJ)</th><th style="text-align: left">Immutable Trees (<code>rust-analyzer</code>)</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Editing API</strong></td><td style="text-align: left"><strong>Simple</strong> (Direct <code>node.delete()</code>)</td><td style="text-align: left"><strong>Verbose</strong> (Requires <code>Builder</code> / rewriting spine)</td></tr>
<tr><td style="text-align: left"><strong>Concurrency</strong></td><td style="text-align: left"><strong>Hard</strong> (Needs complex R/W locks)</td><td style="text-align: left"><strong>Easy</strong> (Snapshots are thread-safe)</td></tr>
<tr><td style="text-align: left"><strong>Mental Model</strong></td><td style="text-align: left">“DOM Manipulation”</td><td style="text-align: left">“Version Control” / Persistent Data Structures</td></tr>
<tr><td style="text-align: left"><strong>Performance</strong></td><td style="text-align: left">Fast small edits</td><td style="text-align: left">Slower (allocates new nodes for the path to root)</td></tr>
</tbody>
</table>
</div>
<h3 id="layer-2-syntaxnode-the-cursor--rednode"><a class="header" href="#layer-2-syntaxnode-the-cursor--rednode">Layer 2: SyntaxNode (The Cursor / RedNode)</a></h3>
<ul>
<li>
<p>GreenNode has some limitations: no parent pointers (can’t go up the tree), and if the same GreenNode appears in multiple places, they’re treated as identical.</p>
</li>
<li>
<p>SyntaxNode/RedNode (also called cursors or <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)">zippers</a>) solve this by adding parent pointers and position information.</p>
</li>
<li>
<p>Conceptual (unoptimized) example from <code>rust-analyzer</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SyntaxNode = Arc&lt;SyntaxData&gt;;

struct SyntaxData {
    offset: usize,
    parent: Option&lt;SyntaxNode&gt;,
    green: Arc&lt;GreenNode&gt;,
}

impl SyntaxNode {
    fn new_root(root: Arc&lt;GreenNode&gt;) -&gt; SyntaxNode {
        Arc::new(SyntaxData {
            offset: 0,
            parent: None,
            green: root,
        })
    }
    fn parent(&amp;self) -&gt; Option&lt;SyntaxNode&gt; {
        self.parent.clone()
    }
    fn children(&amp;self) -&gt; impl Iterator&lt;Item = SyntaxNode&gt; {
        let mut offset = self.offset;
        self.green.children().map(|green_child| {
            let child_offset = offset;
            offset += green_child.text_len;
            Arc::new(SyntaxData {
                offset: child_offset,
                parent: Some(Arc::clone(self)),
                green: Arc::clone(green_child),
            })
        })
    }
}

impl PartialEq for SyntaxNode {
    fn eq(&amp;self, other: &amp;SyntaxNode) -&gt; bool {
        self.offset == other.offset
            &amp;&amp; Arc::ptr_eq(&amp;self.green, &amp;other.green)
    }
}
<span class="boring">}</span></code></pre>
</li>
</ul>
<h4 id="optimizations-1"><a class="header" href="#optimizations-1">Optimizations</a></h4>
<ul>
<li>Atomic avoidance: Use <code>Rc</code> (non-atomic) instead of <code>Arc</code> for parent pointers since traversals are single-threaded anyway, avoiding atomic overhead.</li>
<li>Thread movement: Can’t send <code>SyntaxNode</code> across threads directly, so you send lightweight coordinates like <code>(GreenNode, TextRange)</code> instead. The receiving thread rebuilds the node from those coordinates.</li>
<li>Transient trees: Instead of keeping full trees in memory, <code>rust-analyzer</code> just stores <code>(FileId, TextRange)</code> and reparses when needed—trading CPU time for memory.</li>
<li>Root-only <code>Arc</code>: Only the root holds an <code>Arc&lt;GreenNode&gt;</code> as the tree’s memory anchor. Descendants use raw pointers (fast) plus an <code>Rc</code> to their parent (safe). Since each child’s <code>Rc</code> keeps its parent alive all the way up to the root, the raw pointers never dangle. This means you only pay for atomic operations once at the root—the rest is just cheap <code>Rc</code> bumps.</li>
<li>Object pooling: Keep a thread-local “free list” of node objects for reuse instead of calling <code>malloc</code> constantly. The pool only needs to match traversal depth (not tree size), so a few dozen slots can handle huge trees. This lets you return “owned” nodes cheaply (just a pointer move) which are nicer to work with than references.</li>
</ul>
<h4 id="alternative-designs-1"><a class="header" href="#alternative-designs-1">Alternative Designs</a></h4>
<h5 id="memoized-rednodes"><a class="header" href="#memoized-rednodes">Memoized RedNodes</a></h5>
<ul>
<li>Memoized nodes (C#/Swift): Heavy <code>Arc</code> objects that permanently cache everything—offset, parent, children. You get true pointer equality (super fast comparison) but it doubles memory since the whole tree is duplicated in the “Red” layer. C# tries to claw back memory with weak references.</li>
<li>Cursor approach (<code>rust-analyzer</code>): Lightweight views that calculate positions on demand. Memory scales with traversal depth, not tree size.</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Memoized Design (C# / Swift)
// Persistent, heavy wrapper around the data.
struct SyntaxData {
    offset: usize,
    parent: Option&lt;SyntaxNode&gt;, // Back-link
    // Caches children forever. High memory cost.
    children: Vec&lt;OnceCell&lt;SyntaxNode&gt;&gt;,
}

<span class="boring">}</span></code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Feature</th><th style="text-align: left">Memoized Nodes (C#/Swift)</th><th style="text-align: left">Cursors (<code>rust-analyzer</code>)</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Node Identity</strong></td><td style="text-align: left"><strong>Pointer Equality</strong> (Fast)</td><td style="text-align: left"><strong>Range Check</strong> (Slower)</td></tr>
<tr><td style="text-align: left"><strong>Memory Cost</strong></td><td style="text-align: left"><strong>High</strong> (Doubles tree size)</td><td style="text-align: left"><strong>Low</strong> (Proportional to depth)</td></tr>
<tr><td style="text-align: left"><strong>Child Access</strong></td><td style="text-align: left">Cached (Immediate)</td><td style="text-align: left">Computed (On-demand)</td></tr>
<tr><td style="text-align: left"><strong>Persistence</strong></td><td style="text-align: left">Long-lived Objects</td><td style="text-align: left">Transient / Re-created</td></tr>
</tbody>
</table>
</div>
<h3 id="layer-3-ast-the-api"><a class="header" href="#layer-3-ast-the-api">Layer 3: AST (The API)</a></h3>
<ul>
<li>
<p>A strongly typed API is way more convenient than working with untyped GreenNodes directly (though untyped works fine for error or trivial nodes).</p>
</li>
<li>
<p>For example, having a typed <code>FnDef</code> with well-known methods beats a generic node you have to manually inspect.</p>
</li>
<li>
<p>Example <code>AstNode</code> trait (from <code>rust-analyzer</code>):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AstNode {
  fn cast(syntax: SyntaxNode) -&gt; Option&lt;Self&gt;
  where
      Self: Sized;

  fn syntax(&amp;self) -&gt; &amp;SyntaxNode;
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p>The classes are auto-generated. One example from <code>rust-analyzer</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnDef {
    syntax: SyntaxNode,
}

impl AstNode for FnDef {
    fn cast(syntax: SyntaxNode) -&gt; Option&lt;Self&gt; {
        match syntax.kind {
            SyntaxKind::FN =&gt; Some(FnDef { syntax }),
            _ =&gt; None,
        }
    }
    fn syntax(&amp;self) -&gt; &amp;SyntaxNode {
        &amp;self.syntax
    }
}

impl FnDef {
    pub fn param_list(&amp;self) -&gt; Option&lt;ParamList&gt; {
        self.syntax.children().find_map(ParamList::cast)
    }
    pub fn ret_type(&amp;self) -&gt; Option&lt;RetType&gt; {
        self.syntax.children().find_map(RetType::cast)
    }
    pub fn body(&amp;self) -&gt; Option&lt;BlockExpr&gt; {
        self.syntax.children().find_map(BlockExpr::cast)
    }
    // ...
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p>Variants such as expressions are represented as <code>enum</code>s. One example from <code>rust-analyzer</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssocItem {
    FnDef(FnDef),
    TypeAliasDef(TypeAliasDef),
    ConstDef(ConstDef),
}

impl AstNode for AssocItem {
    ...
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p>Shared syntactic elements (like names, loop bodies, or doc comments) are modeled via traits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HasName: AstNode {
    fn name(&amp;self) -&gt; Option&lt;Name&gt;;
}

impl HasName for FnDef {
    fn name(&amp;self) -&gt; Option&lt;Name&gt; {
        self.syntax.children().find_map(Name::cast)
    }
}
impl HasName for StructDef {
    fn name(&amp;self) -&gt; Option&lt;Name&gt; {
        self.syntax.children().find_map(Name::cast)
    }
}
<span class="boring">}</span></code></pre>
</li>
</ul>
<h4 id="alternative-designs-2"><a class="header" href="#alternative-designs-2">Alternative Designs</a></h4>
<h5 id="semantic-full-ast"><a class="header" href="#semantic-full-ast">Semantic Full AST</a></h5>
<ul>
<li>IntelliJ’s PSI is a “rich” AST that abstracts away where code came from—a <code>PsiMethod</code> looks the same whether it’s from source (<code>.java</code>) or compiled (<code>.jar</code>), hiding all that complexity.</li>
<li>Attached semantics: Nodes have methods like <code>resolve()</code> or <code>getSuperClass()</code> built in, so you can query semantics directly on the tree.</li>
<li>Memory optimization: Start as a lightweight “stub” (just serialized metadata) and only inflates to a full AST when you actually open the file.</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: left">Feature</th><th style="text-align: left">Pure AST (<code>rust-analyzer</code>)</th><th style="text-align: left">Semantic PSI (IntelliJ)</th></tr>
</thead>
<tbody>
<tr><td style="text-align: left"><strong>Scope</strong></td><td style="text-align: left">Source code structure only</td><td style="text-align: left">Source + Compiled Libraries</td></tr>
<tr><td style="text-align: left"><strong>Backing</strong></td><td style="text-align: left">Always AST</td><td style="text-align: left"><strong>Dynamic</strong> (index stub -&gt; full tree)</td></tr>
<tr><td style="text-align: left"><strong>Logic</strong></td><td style="text-align: left">External (analysis passes)</td><td style="text-align: left"><strong>Internal</strong> (methods on nodes)</td></tr>
<tr><td style="text-align: left"><strong>Memory</strong></td><td style="text-align: left">Low (transient cursors)</td><td style="text-align: left">High (rich objects), mitigated by stubs</td></tr>
</tbody>
</table>
</div>
<h2 id="parsing---the-token-sequence-transformer"><a class="header" href="#parsing---the-token-sequence-transformer">Parsing - The Token Sequence Transformer</a></h2>
<ul>
<li>
<p>You can think of parsing as doing a DFS traversal of the tree you want to build.</p>
</li>
<li>
<p>When the parser finishes a node, it calls <code>GreenNodeBuilder</code> to construct it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GreenNodeBuilder { ... }

impl GreenNodeBuilder {
    pub fn new() -&gt; GreenNodeBuilder { ... }

    pub fn token(&amp;mut self, kind: SyntaxKind, text: &amp;str) { ... }

    pub fn start_node(&amp;mut self, kind: SyntaxKind) { ... }
    pub fn finish_node(&amp;mut self) { ... }

    pub fn finish(self) -&gt; GreenNode { ... }
}
<span class="boring">}</span></code></pre>
</li>
<li>
<p>There are two kinds of input: source text (full of trivia like whitespace and comments) and macro token trees (just structural tokens, no trivia).</p>
</li>
<li>
<p>Input and output tokens don’t match 1-to-1. The parser uses abstract callbacks—<code>TokenSource</code> for reading input and <code>TreeSink</code> for writing output. An intermediary layer handles the mismatches, like stripping whitespace or merging <code>&gt;</code> + <code>&gt;</code> into <code>&gt;&gt;</code>.</p>
</li>
<li>
<p>The parser interface (from <code>rust-analyzer</code>):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Different structure than GreenNode's Token
pub struct Token {
  pub kind: SyntaxKind,
  pub is_joined_to_next: bool,
}

pub trait TokenSource {
    fn current(&amp;self) -&gt; Token;
    fn lookahead_nth(&amp;self, n: usize) -&gt; Token;
    fn is_keyword(&amp;self, kw: &amp;str) -&gt; bool;

    fn bump(&amp;mut self);
}

pub trait TreeSink {
    fn token(&amp;mut self, kind: SyntaxKind, n_tokens: u8);

    fn start_node(&amp;mut self, kind: SyntaxKind);
    fn finish_node(&amp;mut self);

    fn error(&amp;mut self, error: ParseError);
}

pub fn parse(
    token_source: &amp;mut dyn TokenSource,
    tree_sink: &amp;mut dyn TreeSink,
) { ... }
<span class="boring">}</span></code></pre>
</li>
<li>
<p>The <code>parser</code> and <code>syntax</code> crates are completely separate with zero dependencies on each other, achieving strict modularity.</p>
</li>
<li>
<p>The parser mostly works with <code>SyntaxKind</code> tags and ignores the actual text, except for one hack: checking contextual keywords like <code>union</code> or <code>default</code>.</p>
</li>
<li>
<p><code>TreeSink</code> isn’t atomic. When the parser emits a logical token like <code>&gt;&gt;</code>, the sink can consume multiple raw tokens (<code>&gt;</code> and <code>&gt;</code>).</p>
</li>
</ul>
<h3 id="reporting-syntax-errors"><a class="header" href="#reporting-syntax-errors">Reporting Syntax Errors</a></h3>
<ul>
<li>Errors aren’t stored in the tree, they’re collected separately in a <code>Vec&lt;SyntaxError&gt;</code>.</li>
<li>This separation means you can build or modify trees manually without worrying about error state.</li>
<li>The parser is intentionally permissive (like allowing <code>pub</code> on trait methods). These “soft” errors get caught later in a validation pass.</li>
</ul>
<h3 id="macros"><a class="header" href="#macros">Macros</a></h3>
<ul>
<li>Token hygiene: Macros need to remember where tokens came from so variables with the same name from different scopes don’t get confused. While building the tree, <code>TreeSink</code> also creates a map linking text ranges back to their original token IDs. So parsing gives you two things: the tree and a map tracing everything back to its source.</li>
<li>Operator precedence: To avoid breaking precedence (like <code>$expr * 1</code> messing up order of operations), the parser adds invisible parentheses around macro expansions.</li>
</ul>
<h3 id="whitespace--comments"><a class="header" href="#whitespace--comments">Whitespace &amp; Comments</a></h3>
<ul>
<li>The core parser works with a “clean” token stream—no whitespace or comments to worry about.</li>
<li>But trivia isn’t thrown away. The <code>TreeSink</code> layer re-inserts it into the final tree as nodes get built.</li>
<li>Comments don’t just get dumped linearly—they’re attached heuristically to their semantic parents. Like a comment right before a function becomes a child of that <code>FnDef</code> node.</li>
</ul>
<h3 id="incremental-reparse"><a class="header" href="#incremental-reparse">Incremental Reparse</a></h3>
<ul>
<li>Green trees make modifications cheap—you can “patch” by swapping a single node pointer with a freshly parsed subtree. No external state needed.</li>
<li>Block heuristic: Edits get isolated to the smallest <code>{}</code> block that contains them. This works because the parser keeps braces balanced even in broken code, giving you stable anchor points.</li>
</ul>
<details>
<summary><strong>Q&amp;A: How does the parser maintain balanced braces in broken code?</strong></summary>
<p><strong>Q: How can braces be “balanced” when users type unmatched <code>{</code> or <code>}</code>?</strong></p>
<p>A: The <strong>tree structure</strong> maintains balanced braces, not the source text. The parser uses error recovery to ensure every <code>start_node(BLOCK)</code> has a matching <code>finish_node()</code>.</p>
<p><strong>Q: What happens when a closing brace is missing?</strong></p>
<p>A: The parser inserts an <strong>implicit/phantom closing brace</strong>. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 1;
// EOF - missing }
<span class="boring">}</span></code></pre>
<p>The tree structure acts as if the <code>}</code> exists at EOF, even though it’s not in the source text. This is implemented in the parser’s <a href="https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_parser/src/grammar/expressions/atom.rs#L476-L481">block parsing logic</a>, which automatically closes unclosed blocks at EOF or when encountering incompatible tokens.</p>
<p><strong>Q: What if there’s an unexpected token inside a block?</strong></p>
<p>A: The parser uses <strong>early block termination</strong>. For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 1;
fn bar() {  // unexpected fn - shouldn't be here
<span class="boring">}</span></code></pre>
<p>The parser:</p>
<ul>
<li>Realizes <code>fn</code> shouldn’t be inside <code>foo</code>’s block</li>
<li>Inserts an implicit <code>}</code> to close <code>foo</code></li>
<li>Continues parsing <code>bar</code> at the outer level</li>
<li>Wraps the malformed content in an <code>ERROR</code> node</li>
</ul>
<p>This is part of the “panic mode” error recovery strategy implemented in the <a href="https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_parser/src/event.rs#L21-L129">event-based parser</a>.</p>
<p><strong>Q: What about extra closing braces?</strong></p>
<p>A: Unmatched <code>}</code> tokens are:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
}
}  // extra closing brace
<span class="boring">}</span></code></pre>
<ul>
<li>Treated as error tokens</li>
<li>Wrapped in an <code>ERROR</code> node</li>
<li>Not matched with anything</li>
<li>The structural tree still has balanced blocks</li>
</ul>
<p><strong>Q: How does this enable the block heuristic?</strong></p>
<p>A: Because braces are always structurally balanced, the parser can reliably:</p>
<ul>
<li>Find the smallest enclosing <code>{}</code> block around any edit</li>
<li>Use these blocks as stable anchor points</li>
<li>Reparse just that subtree instead of the entire file</li>
</ul>
<p>This is implemented in the <a href="https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax/src/parsing/reparsing.rs#L24-L148">incremental reparsing logic</a> in the <code>syntax</code> crate, particularly the <code>incremental_reparse</code> function and <code>is_balanced</code> check.</p>
</details>
<ul>
<li>In practice though, incremental reparsing often isn’t worth it. Modern parsers are fast enough to just reparse the whole file from scratch.</li>
</ul>
<h2 id="parsing-algorithm"><a class="header" href="#parsing-algorithm">Parsing Algorithm</a></h2>
<ul>
<li>Recursive descent: Each grammar rule maps to a function that calls other functions recursively to parse sub-expressions. This makes the parser easy to understand and debug.</li>
<li>Pratt parsing: Handle operator precedence elegantly without building complex precedence tables. Used specifically for expressions with binary operators.</li>
<li>Error recovery: The parser makes a special effort to continue parsing even when it encounters syntax errors. Instead of stopping at the first error, it attempts to recover and continue building the tree, marking problematic sections with <code>ERROR</code> nodes.</li>
</ul>
<h3 id="parser-recap"><a class="header" href="#parser-recap">Parser Recap</a></h3>
<p>The parser’s design achieves strict modularity through well-defined interfaces:</p>
<ul>
<li><code>TokenSource</code> trait:
<ul>
<li>Define how the parser reads input tokens.</li>
<li>The parser doesn’t know or care whether tokens come from source text (with trivia), macro expansions (without trivia), or any other source.</li>
</ul>
</li>
<li><code>TreeSink</code> trait:
<ul>
<li>Define how the parser writes output events (<code>start_node</code>, <code>finish_node</code>, <code>token</code>, <code>error</code>).</li>
<li>The parser has no knowledge of how these events are converted into the final tree structure.</li>
</ul>
</li>
</ul>
<h2 id="interaction-between-the-syntax-and-the-parser-crate"><a class="header" href="#interaction-between-the-syntax-and-the-parser-crate">Interaction Between The <code>syntax</code> and The <code>parser</code> Crate</a></h2>
<p>The <code>parser</code> and <code>syntax</code> crates have <strong>zero dependencies</strong> on each other. Both crates depend on shared interfaces (traits), but neither depends on the other’s implementation.</p>
<pre class="mermaid">%%{init: {'theme':'neutral', 'themeVariables': {'fontSize':'16px'}}}%%
flowchart LR
    A(["&lt;i&gt;string&lt;/i&gt;&lt;br/&gt;&lt;b&gt;Source Text&lt;/b&gt;"])

    subgraph top["&lt;code&gt;syntax&lt;/code&gt; crate"]
        direction LR
        B["&lt;i&gt;fn&lt;/i&gt;&lt;br/&gt;&lt;b&gt;tokenize&lt;/b&gt;"]
        C(["&lt;i&gt;Vec&amp;lt;Token&amp;gt;&lt;/i&gt;&lt;br/&gt;&lt;b&gt;Token Stream&lt;/b&gt;"])
        B --&gt; C
    end

    subgraph P["&lt;code&gt;parser&lt;/code&gt; crate"]
        direction LR
        D{{"&lt;i&gt;trait&lt;/i&gt;&lt;br/&gt;&lt;b&gt;TokenSource&lt;/b&gt;"}}
        E["&lt;i&gt;fn&lt;/i&gt;&lt;br/&gt;&lt;b&gt;parse&lt;/b&gt;"]
        F{{"&lt;i&gt;trait&lt;/i&gt;&lt;br/&gt;&lt;b&gt;TreeSink&lt;/b&gt;"}}
        D --&gt; E --&gt; F
    end

    subgraph bottom["&lt;code&gt;syntax&lt;/code&gt; crate"]
        direction RL
        I{{"&lt;i&gt;trait&lt;/i&gt;&lt;br/&gt;&lt;b&gt;AstNode&lt;/b&gt;"}}
        H(["&lt;i&gt;type&lt;/i&gt;&lt;br/&gt;&lt;b&gt;SyntaxNode&lt;/b&gt;"])
        G(["&lt;i&gt;type&lt;/i&gt;&lt;br/&gt;&lt;b&gt;GreenNode&lt;/b&gt;"])
        G --&gt; H --&gt; I
    end

    A --&gt; B
    C -.-&gt;|implements| D
    F -.-&gt;|implemented by| G

    click B "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax/src/parsing/lexer.rs#L30-L92" "View tokenize function"
    click C "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax/src/parsing/lexer.rs#L9-L15" "View Token struct"
    click D "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_parser/src/lib.rs#L30-L44" "View TokenSource trait"
    click E "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_parser/src/lib.rs#L81-L84" "View parse function"
    click F "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_parser/src/lib.rs#L56-L69" "View TreeSink trait"
    click G "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax/src/syntax_node.rs#L10-L10" "View GreenNode type"
    click H "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax/src/syntax_node.rs#L33-L34" "View SyntaxNode type alias"
    click I "https://github.com/rust-lang/rust-analyzer/blob/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax/src/ast.rs#L31-L42" "View AstNode trait"

    classDef syntaxNode fill:#dbeafe,stroke:#3b82f6,stroke-width:2px,color:#1e40af
    classDef parserNode fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#9a3412
    classDef dataNode fill:#e5e7eb,stroke:#6b7280,stroke-width:2px,color:#374151
    classDef traitNode fill:#fce7f3,stroke:#db2777,stroke-width:2px,color:#831843

    class B,E syntaxNode
    class A,C,G,H dataNode
    class D,F,I traitNode

    style top fill:#eff6ff,stroke:#3b82f6,stroke-width:2px,rx:5
    style bottom fill:#eff6ff,stroke:#3b82f6,stroke-width:2px,rx:5
    style P fill:#fff7ed,stroke:#f97316,stroke-width:2px,rx:5
</pre>

<ul>
<li>The <strong>solid arrows</strong> represent direct data flow within the same crate. The <strong>dashed arrows</strong> represent trait implementation/interface contracts.</li>
<li>The <code>parser</code> crate (orange box) only touches <strong>traits</strong> - it never directly depends on concrete types from <code>syntax</code>.</li>
<li>The <code>syntax</code> crate appears in two boxes because it provides both the input preparation (tokenization) and output consumption (tree building), but the parser sits independently in the middle.</li>
<li>This architecture is like an “hourglass”: wide input capabilities (multiple token sources), narrow interface (two traits), wide output capabilities (multiple tree representations).</li>
</ul>
<h3 id="how-they-work-together"><a class="header" href="#how-they-work-together">How They Work Together</a></h3>
<ol>
<li>The <code>syntax</code> crate tokenizes the source text into a token stream.</li>
<li>The <code>syntax</code> crate wraps its token stream in a struct that implements the <code>TokenSource</code> trait, providing the interface the parser expects.</li>
<li>The <code>parser</code> crate’s <code>parse()</code> function reads from <code>TokenSource</code> and writes to <code>TreeSink</code> - it only knows about these trait interfaces, not the concrete implementations</li>
<li>The <code>syntax</code> crate provides a struct implementing <code>TreeSink</code> that receives parser events and builds the actual <code>GreenNode</code> tree structure</li>
<li>The <code>syntax</code> crate wraps the <code>GreenNode</code> in <code>SyntaxNode</code> and provides the typed AST layer</li>
</ol>
<p>Insight: The <code>parser</code> crate emits abstract <strong>events</strong> (<code>start_node</code>, <code>token</code>, <code>finish_node</code>, <code>error</code>) without knowing how they’ll be consumed. The <code>syntax</code> crate provides concrete implementations that convert these events into the tree structure.</p>
<p><strong>What the parser knows vs doesn’t know:</strong></p>
<ul>
<li><strong>Knows</strong>: <code>SyntaxKind</code> tags (e.g., <code>FN_DEF</code>, <code>IDENT</code>, <code>LET_STMT</code>), the vocabulary of what syntactic constructs exist.</li>
<li><strong>Knows</strong>: When to emit events like <code>start_node(FN_DEF)</code> or <code>token(IDENT)</code> based on parsing logic.</li>
<li><strong>Doesn’t know</strong>: How these events are converted into actual tree nodes (<code>GreenNode</code>, <code>SyntaxNode</code>).</li>
<li><strong>Doesn’t know</strong>: The memory layout, data structures, or APIs of the tree.</li>
</ul>
<p><code>SyntaxKind</code> is just a simple enum/tag shared between both crates. The parser uses it to label events, while the <code>syntax</code> crate uses it to tag tree nodes. This shared vocabulary is the only coupling between them.</p>
<h4 id="illustrative-example"><a class="header" href="#illustrative-example">Illustrative example</a></h4>
<p>The example glue code in <code>syntax</code> crate</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `syntax` crate

pub fn parse_source_file(text: &amp;str) -&gt; SourceFile {
    // Step 1: Tokenize the source text (syntax crate's job)
    let tokens = tokenize(text);

    // Step 2: Create adapters that implement parser traits
    let mut token_source = TokenSource::new(text, &amp;tokens);
    let mut tree_sink = TreeSink::new(text, &amp;tokens);

    // Step 3: Call the parser (parser crate's job)
    // The parser only sees the trait interfaces, not the concrete types
    parser::parse(&amp;mut token_source, &amp;mut tree_sink);

    // Step 4: Extract the built tree (syntax crate's job)
    let (green_node, errors) = tree_sink.finish();

    // Step 5: Wrap in higher-level APIs
    SourceFile::new(green_node, errors)
}
<span class="boring">}</span></code></pre>
<h3 id="motivation"><a class="header" href="#motivation">Motivation</a></h3>
<p>This separation provides several benefits:</p>
<ul>
<li>The parser logic can change without touching tree representation, and vice versa.</li>
<li>Different token sources (source files, macro expansions, synthetic tokens) can all use the same parser.</li>
<li>Different tree sinks could produce different tree formats, or even non-tree outputs (e.g., streaming validation).</li>
<li>The parser can be tested with mock token sources and tree sinks.</li>
<li>The parser is truly language-agnostic - it could theoretically be reused for other languages by providing different <code>SyntaxKind</code> definitions.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../research/resources/rust-analyzer/coding_conventions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../../../research/resources/rust-analyzer/tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../research/resources/rust-analyzer/coding_conventions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../../../research/resources/rust-analyzer/tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../../../mark-09e88c2c.min.js"></script>
        <script src="../../../searcher-c2a407aa.js"></script>

        <script src="../../../clipboard-1626706a.min.js"></script>
        <script src="../../../highlight-abc7f01d.js"></script>
        <script src="../../../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../theme/mermaid-3a6b472a.min.js"></script>
        <script src="../../../theme/mermaid-init-025d9952.js"></script>



    </div>
    </body>
</html>
